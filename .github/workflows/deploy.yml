name: 'üöÄ Deploy Next.js Docker App'

on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    runs-on: self-hosted
    name: 'üê≥ Build & Deploy'
    steps:
      - name: 'üîç Checkout Code'
        uses: actions/checkout@v4

      # (Secrets and .env setup steps remain the same)
      - name: 'üîí Verify Secrets Exist'
        run: |
          if [ -z "${{ secrets.GOOGLE_SERVICES_JSON_BASE64 }}" ]; then
            echo "‚ùå Critical error: GOOGLE_SERVICES_JSON_BASE64 secret missing!"
            exit 1
          fi
          echo "‚úÖ All secrets present"

      - name: 'üìÅ Create google-services.json'
        run: |
          echo "$GOOGLE_SERVICES_JSON_BASE64" | base64 --decode > google-services.json
          echo "üîÑ Validating JSON..."
          if ! jq empty google-services.json; then
            echo "‚ùå JSON validation failed!"
            exit 1
          fi
        env:
          GOOGLE_SERVICES_JSON_BASE64: ${{ secrets.GOOGLE_SERVICES_JSON_BASE64 }}

      - name: '‚öôÔ∏è Create .env File'
        run: |
          echo "${{ secrets.ENV_FILE_CONTENT }}" > .env
          echo "" >> .env

      # =======================================================
      # üê≥ Docker Operations (This section is updated)
      # =======================================================
      - name: 'üöÄ Build, Launch, and Update Services'
        run: |
          # Step 1: Ensure the Docker network exists.
          if ! docker network ls | grep -q "codebuilder-net"; then
            echo "Network 'codebuilder-net' not found. Creating it..."
            docker network create codebuilder-net
          else
            echo "Network 'codebuilder-net' already exists. Skipping creation."
          fi

          # Step 2: Start the database service independently.
          # The 'up -d' command is idempotent; it will start the 'db' if it's not running,
          # and do nothing if it already is.
          echo "Starting database service..."
          docker compose up -d db

          # Step 3: Wait for the database to be fully ready.
          # We use netcat (nc) to poll the database port exposed to the host machine.
          # This is critical to ensure the build doesn't start prematurely.
          # NOTE: We use port 5434 because that is what you mapped in your docker-compose.yml
          echo "Waiting for database to become available on localhost:5434..."
          while ! nc -z localhost 5434; do
            sleep 1 # wait for 1 second before trying again
          done
          echo "‚úÖ Database is healthy and listening."

          # Step 4: NOW that the DB is running, build the webapp image.
          # The Docker builder will be able to connect to the 'db' service over the network.
          echo "Building the webapp image..."
          docker compose build webapp

          # Step 5: Deploy the newly built webapp container.
          # This command surgically replaces the webapp without touching the database.
          echo "Deploying the new webapp container..."
          docker compose up -d --no-deps --force-recreate webapp

      - name: 'üóë Prune Old Docker Images'
        if: always()
        run: docker image prune -af
